import Router from "koa-router";
import autoGeneratedControllers from "../controllers/autoGeneratedControllers.js";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";

export default function dynamicRoutes(apickApp) {
  const { database, _app, ...rest } = apickApp;
  const router = new Router();

  // Fetch the list of collections from the database
  database.getCollections().then((data) => {
    // Create routes for each collection
    Object.keys(data).forEach((entry) => {
      if (entry) {
        const controller = autoGeneratedControllers(database, entry);

        // Define the routes
        router.get(`/${entry}`, controller.get);
        router.get(`/${entry}/:id`, controller.get);
        router.post(`/${entry}`, controller.post);
        router.put(`/${entry}/:id`, controller.put);
        router.patch(`/${entry}/:id`, controller.patch);
        router.delete(`/${entry}/:id`, controller.del);
      }
    });
  });

  registerUserRoute(router, database);
  loginUserRoute(router, database);
  getDatabaseRoute(router, database);
  getCollectionsRoute(router, database);
  renameCollectionRoute(router, database);
  createCollectionRoute(router, database);
  getCustomRoutesRoute(router, database);
  restartServerRoute(router, _app);


  // router.post("/__restart-server", async (ctx) => {
  //   // Add any authentication or access control here, if necessary

  //   ctx.body = { message: "Server restarting..." };

  //   // Restart the server after a small delay
  //   setTimeout(() => {
  //     console.log('*************************************')
  //     console.log(JSON.stringify(apickApp, null, 2))

  //     apickApp.emit("close");
  //     apickApp.callback().then(() => {
  //       // Re-run your server initialization code here
  //       // E.g., if your server is started with something like `app.listen(3000);`, re-run that

  //     });
  //     console.log('*************************************')
  //   }, 500);
  // });

  // router.post("/__restart-server", async (ctx) => {
  //   ctx.body = { message: "Server restarting..." };

  //   // Restart the server after a small delay
  //   setTimeout(async () => {
  //     apickApp.server.close();
  //     await apickApp._app.listen(3000);
  //     console.log('Server restarted.');
  //   }, 1000);
  // });

  router.post("/__restart-server", async (ctx) => {
    ctx.body = { message: "Server restarting..." };
  
    // Restart the server after a small delay
    setTimeout(() => {
      apickApp.server.close(async () => {
        console.log('Server closed.');

        // apickApp.server = await apickApp._app.listen(3000);
        apickApp.listen(3000);
        console.log('Server restarted.');
      
      
      });
    }, 1000);
  });
  


  // Return the routes middleware
  return router.routes();
}

// Restart server route
function restartServerRoute(router, app) {

}


// Register route
function registerUserRoute(router, database) {
  router.post("/register", async (ctx) => {
    const { username, password, id } = ctx.request.body;
    const hashedPassword = await bcrypt.hash(password, 10);

    const newUserId = id || (await database.getMaxId("users")) + 1;

    // Insert new user
    const newUser = await database.insert("users", {
      username,
      password: hashedPassword,
      id: newUserId,
    });
    ctx.body = newUser;
  });
}

// Login route
function loginUserRoute(router, database) {
  router.post("/login", async (ctx) => {
    const { username, password } = ctx.request.body;
    const user = (await database.find("users", [["username", username]]))[0];

    if (!user) {
      ctx.throw(401, "Invalid username");
    }

    // Verify the password
    const valid = await bcrypt.compare(password, user.password);

    if (valid) {
      const token = jwt.sign({ username }, "your_secret_key");
      ctx.body = { token, user };
    } else {
      ctx.throw(401, "Invalid username or password");
    }
  });
}

// Get database route
function getDatabaseRoute(router, database) {
  router.get("/__db", async (ctx) => {
    const collections = await database.getCollections();
    ctx.body = collections;
  });
}

// Get collections route
function getCollectionsRoute(router, database) {
  router.get("/__collections", async (ctx) => {
    const collections = await database.getCollections();
    ctx.body = Object.keys(collections);
  });
}

// Rename collection route
function renameCollectionRoute(router, database) {
  router.patch("/__collections/:collection", async (ctx) => {
    const oldName = ctx.params.collection;
    const { newName } = ctx.request.body;

    // Check if the new collection name is provided
    if (!newName) {
      ctx.throw(400, "Missing new collection name");
    }

    // Check if the collection with the new name already exists
    if (await checkCollectionExists(database, newName)) {
      ctx.throw(400, `Collection '${newName}' already exists`);
    }

    // Rename the collection
    await database.renameCollection(oldName, newName);
    ctx.body = { message: `Collection '${oldName}' renamed to '${newName}'` };
  });
}

// Create collection route
function createCollectionRoute(router, database) {
  router.post("/__collections", async (ctx) => {
    const { name } = ctx.request.body;

    // Check if the collection name is provided
    if (!name) {
      ctx.throw(400, "Missing collection name");
    }

    // Check if the collection with the given name already exists
    if (await checkCollectionExists(database, name)) {
      ctx.throw(400, `Collection '${name}' already exists`);
    }

    // Create a new collection with the provided name
    await database.createCollection(name);
    ctx.body = { message: `Collection '${name}' created successfully` };
  });
}

// Get custom routes route
function getCustomRoutesRoute(router, database) {
  router.get("/__custom-routes", async (ctx) => {
    ctx.body = await getCustomRoutes(router, database);
  });
}

// -- Utils -- to make above code cleaner
// Helper function to check if a collection with the given name exists
async function checkCollectionExists(database, collectionName) {
  const collections = await database.getCollections();
  return Object.keys(collections).includes(collectionName);
}

async function getCustomRoutes(router, database) {
  const customRoutes = [];

  // Get all the registered routes in the router
  const registeredRoutes = router.stack.map((route) => ({
    method: route.methods.filter((method) => method !== "HEAD")[0],
    path: route.path,
  }));

  // Get all the collections from the database
  const collections = await database.getCollections();

  // Filter out the routes that are related to the collections
  const collectionRoutes = Object.keys(collections).flatMap((collection) => [
    `/${collection}`,
    `/${collection}/:id`,
  ]);

  for (const registeredRoute of registeredRoutes) {
    if (!collectionRoutes.includes(registeredRoute.path)) {
      customRoutes.push(registeredRoute);
    }
  }

  return customRoutes;
}
